{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the Tidi documentation.</p> <p>Tidi is a small dependency injection Python\u00a0library.</p> <p>It's aim, apart from being a learning outcome of the author, is to provide a clean, type checker compliant, API for medium sized projects to benefit from Inversion of Control (IoC) through applying Dependency Injection (DI) without having to adopt a large DI framework.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install tidi\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#example-usage","title":"Example usage","text":"<pre><code>import tidi\nfrom my_package.auth import AuthError, AuthService\nfrom my_package.db import DBSession, QueuedJob, create_db_session\nfrom my_package.job import Job, JobQueue\n@tidi.inject\ndef process_job(\njob: Job,\ndb_session: tidi.Injected[DBSession] = tidi.Provider(create_db_session)\nauth_service: tidi.Injected[AuthService] = tidi.UNSET,\n):\nif not auth_service.is_logged_in_user_authorised_for_job(job.name):\nraise AuthError(\"Unauthorised to run this job :(\")\njob.run(db_session=db_session)\n@tidi.inject\nclass JobQueue:\ndef __init__(\nself,\ndb_session: tidi.Injected[DBSession] = tidi.Provider(create_db_session)\n):\nself.jobs = db_session.query(QueuedJob).all()\ndef init_app():\nauth_service = AuthService()\nauth_service.log_in_user()\ntidi.register(auth_service)\ndef main():\ninit_app()\nfor job in JobQueue().jobs:  # \ud83e\ude84 `DBSession` injected into `JobQueue` \u2728\nprocess_job(job)  # \ud83e\ude84 `DBSession` and `AuthService` injected into `process_job` \u2728\nif __name__ == \"__main__\":\nmain()\n</code></pre> <p>Or see more examples in the <code>demo/</code> directory of the repo.</p>"},{"location":"#further-documentation-of-use","title":"Further documentation of use","text":"<p>See the Usage guide for more details</p>"},{"location":"#motivation","title":"Motivation","text":"<p>I found myself wanting to learn more about how DI can be done in a pythonic way, with type-hinting, so had the itch to develop (yet another) library for it and share it as open source \ud83e\uddd1\u200d\ud83d\udcbb\u270c\ufe0f</p> <p>My main inspiration was Kent Tong's disl and FastAPI's <code>Depends</code>.</p>"},{"location":"#contribution-guide","title":"Contribution guide","text":"<p>If you'd like to contribute to the development of Tidi, please clone the repo and read the CONTRIBUTING.md</p>"},{"location":"usage/","title":"Usage","text":"<p>There are a few main ways it's intended to be used.</p>"},{"location":"usage/#examples-of-usage","title":"Examples of usage","text":""},{"location":"usage/#inject-a-dependency-that-has-been-put-in-a-registry","title":"Inject a dependency that has been put in a\u00a0registry","text":"<pre><code>import tidi\n@tidi.inject\ndef run(auth: tidi.Injected[AuthService] = tidi.UNSET):\nif auth.is_super_user():\nlogger.info(f\"Running with elevated permissions.\")\n...\nif __name__ == \"__main__\":\ntidi.register(AuthService())\n...\nrun()  # \ud83e\ude84 `AuthService` injected into `run` \u2728\n</code></pre>"},{"location":"usage/#inject-a-dependency-provided-by-a-function","title":"Inject a dependency provided by a\u00a0function","text":"<pre><code>import tidi\ndef get_secret() -&gt; str:\nreturn \"wshwshwhswhs\"\ndef run(secret: tidi.Injected[str] = tidi.Provider(get_secret)):\nlogger.info(f\"don't tell anyone this but, {secret}\")\nif __name__ == \"__main__\":\nrun()  # \ud83e\ude84 result from `get_secret()` injected into `run` \u2728\n</code></pre>"},{"location":"usage/#or-provided-by-instantiating-a-class","title":"Or provided by instantiating a\u00a0class","text":"<pre><code>import tidi\nclass Database():\ndef __init__(self, db_string = \"fridge\"):\nself.db_string = db_string\ndef get_snack(self):\nreturn f\"snack, out of the {self.db_string}\"\ndef eat_snack(db: tidi.Injected[Database] = tidi.Provider(Database)):\nlogger.info(f\"eating {db.get_snack()}\")\nif __name__ == \"__main__\":\neat_snack()  # \ud83e\ude84 a new `Database` injected into `run` \u2728\n</code></pre>"},{"location":"usage/#the-injection-also-works-with-classes-either-into-the-constructor","title":"The injection also works with classes, either into the constructor","text":"<pre><code>import tidi\n@tidi.inject\nclass Algorithm:\ndef __init__(self, config: tidi.Injected[Config] = tidi.UNSET):\nself.tolerance = config.tolerance\ndef run(self, input_value: float) -&gt; float:\nreturn input_value - input_value * self.tolerance\nif __name__ == \"__main__\":\ntidi.register(Config(tolerance=0.1))\nalg = Algorithm()  # \ud83e\ude84 `Config` injected into new `Algorithm` instance \u2728\nalg.run(10.0)\n</code></pre>"},{"location":"usage/#or-into-their-methods","title":"Or into their\u00a0methods","text":"<pre><code>import tidi\nclass Job:\ndef __init__(self, name):\nself.name = name\n@tidi.inject\ndef run(self, db: tidi.Injected[DBConn] = tidi.Provided(get_db_conn)):\nlogger.info(f\"run job {self.name} using database {db.name}\")\nif __name__ == \"__main__:\njob = Job(\"new job\")\njob.run()  # \ud83e\ude84 `DBConn` injected into `job.run` \u2728\n</code></pre>"},{"location":"usage/#and-to-inject-dependencies-into-a-dataclass-use-the-field_factory","title":"And to inject dependencies into a dataclass, use the field_factory","text":"<pre><code>import tidi\n@dataclass\nclass Output:\nvalue: float\ncreated_by: User = field(default_factory=tidi.field_factory(User))\ndef process():\nreturn Output(value=1)  # \ud83e\ude84 `User` injected into `Output.created_by` \u2728\nif __name__ == \"__main__\":\ncurrent_user = User.from_env_credentials()\ntidi.register(current_user)\noutput = process(job)\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#main-api","title":"Main API","text":"<p>The top level import of <code>tidi</code> provides everything needed it's primary intended use.</p> <ul> <li><code>tidi.inject</code> - a decorator that will replace certain keyword arguments with dependencies, based on their type &amp; if they haven't been passed in</li> <li><code>tidi.Injected</code> - a type alias, wrapping <code>typing.Annotated</code>, that indicates that a keyword argument should be injected</li> <li><code>tidi.register</code> - a function that registers an object to be available for injection as a dependency</li> <li><code>tidi.Provider</code> - a wrapper class around a function that will be called to provide a dependency</li> <li><code>tidi.UNSET</code> - a sentinel object to indicate that a dependency should be loaded from the registry</li> <li><code>tidi.field_factory</code> - a helper function for injecting dependencies into dataclass fields</li> </ul>"},{"location":"reference/#tidiinject-tidiinjected-tidiunset","title":"<code>tidi.inject</code>, <code>tidi.Injected</code>, &amp; <code>tidi.UNSET</code>","text":"<p><code>@tidi.inject</code> will injects dependencies into keyword arguments with the <code>tidi.Injected</code> type annotation.</p> <p>If the default value is <code>tidi.UNSET</code>, it will search for that dependency in the registry.</p> <pre><code>@tidi.inject\ndef get_users(db: tidi.Injected[Database] = tidi.UNSET):\ndb.query(Users).all()\n</code></pre> <p>See the <code>tidi.decorator</code> documentation for more detail.</p>"},{"location":"reference/#tidiregister","title":"<code>tidi.register</code>","text":"<p>To register a dependency instance, simple call the <code>tidi.register</code> function</p> <pre><code>database = load_database()\ntidi.register(database)\n</code></pre> <p>This puts it into the default registry which is shared across </p> <p>See the <code>tidi.registry</code> documentation for more detail.</p>"},{"location":"reference/#tidiprovider","title":"<code>tidi.Provider</code>","text":"<p>For more control over what instance is injected, use the provider function.</p> <p>The elected provider function will be called each time the function is called.</p> <pre><code>@tidi.inject\ndef get_users(db: tidi.Injected[Database] = tidi.Provider(load_database)):\ndb.query(Users).all()\n</code></pre> <p>See the <code>tidi.decorator</code> documentation for more detail.</p>"},{"location":"reference/#tidifield_factory","title":"<code>tidi.field_factory</code>","text":"<p>When working with dataclasses, the <code>inject</code> decorator doesn't work, so use the <code>field_factory</code> convenience function to inject the dependency into a field upon instance creation.</p> <pre><code>from dataclasses import dataclass, field\n@dataclass\nclass UserQuery:\nname: str\ndb: Database = field(default_factory=tidi.field_factory(Database))\nuser_query = UserQuery()\nexecute_user_query(user_query)\n</code></pre>"},{"location":"reference/#modules","title":"Modules","text":"<p>Tidi's codebase consists of the following four, relatively small modules:</p> <ul> <li><code>tidi.decorator</code> - provides the main inject decorator, using <code>tidi.parameters</code> to determine which parameters of the wrapped function to replace</li> <li><code>tidi.parameters</code> - background wrapper of the builtin <code>inspect.Parameter</code> class for determining which function parameters are annotated</li> <li><code>tidi.registry</code> - provides simple registry class for holding dependency instances, stored in a dictionary (map), using their type as the key</li> <li><code>tidi.resolver</code> - contains the logic used to either find an object from the registry or from a provider function</li> </ul>"},{"location":"reference/decorator/","title":"Decorator module","text":""},{"location":"reference/decorator/#tidi.decorator","title":"<code>tidi.decorator</code>","text":"<p>Provides the main <code>inject</code> decorator.</p> <p>Uses <code>tidi.parameters</code> to determine which parameters of the wrapped function to replace.</p>"},{"location":"reference/decorator/#tidi.decorator.UNSET","title":"<code>UNSET = Unset()</code>  <code>module-attribute</code>","text":"<p>Sentinel <code>Unset</code> object used to indicate a kwarg is not set yet.</p>"},{"location":"reference/decorator/#tidi.decorator.Provider","title":"<code>Provider</code>","text":"<p>             Bases: <code>typing.Generic[T]</code>, <code>Any</code></p> <p>Wrapper class around a function that will be called to provide a dependency</p> <p>Parameters:</p> Name Type Description Default <code>provider_func</code> <code>Callable</code> <p>Callable that will return a given type (TypeVar <code>T</code>) which will be used as the dependency.</p> required <p>Examples:</p> <p>Define a provider function</p> <pre><code>&gt;&gt;&gt; def get_big_toolbox() -&gt; Toolbox:\n&gt;&gt;&gt;     return ...\n</code></pre> <p>Give the provider function into the kwarg marked for injected</p> <pre><code>&gt;&gt;&gt; @tidi.inject\n... def get_hammers(\n...     toolbox: tidi.Injected[Toolbox] = tidi.Provider(get_big_toolbox)\n... ) -&gt; list[Hammer]:\n...     return [tool for tool in toolbox.tools if isinstance(tool, Hammer)]\n</code></pre> <p>Now when you call <code>get_hammers</code>, Tidi will call <code>get_big_toolbox</code> and inject it into the <code>toolbox</code> kwarg</p> <pre><code>&gt;&gt;&gt; get_hammers()\n</code></pre> Source code in <code>src/tidi/decorator.py</code> <pre><code>class Provider(t.Generic[T], t.Any):  # inherit from Any to appease type checkers\n\"\"\"Wrapper class around a function that will be called to provide a dependency\n    Args:\n        provider_func (typing.Callable): Callable that will return a given\n            type (TypeVar `T`) which will be used as the dependency.\n    Examples:\n        Define a provider function\n        &gt;&gt;&gt; def get_big_toolbox() -&gt; Toolbox:\n        &gt;&gt;&gt;     return ...\n        Give the provider function into the kwarg marked for injected\n        &gt;&gt;&gt; @tidi.inject\n        ... def get_hammers(\n        ...     toolbox: tidi.Injected[Toolbox] = tidi.Provider(get_big_toolbox)\n        ... ) -&gt; list[Hammer]:\n        ...     return [tool for tool in toolbox.tools if isinstance(tool, Hammer)]\n        Now when you call `get_hammers`, Tidi will call `get_big_toolbox` and\n        inject it into the `toolbox` kwarg\n        &gt;&gt;&gt; get_hammers()\n    \"\"\"\n# overloading new to avoid issue with the `Any` inheritance\n@classmethod\ndef __new__(cls, *args, **kwargs) -&gt; t.Self:\nreturn super().__new__(cls)\ndef __init__(self, provider_func: t.Callable[..., T]):\nself.provider_func = provider_func\n</code></pre>"},{"location":"reference/decorator/#tidi.decorator.Unset","title":"<code>Unset</code>","text":"<p>             Bases: <code>Any</code></p> <p>Placeholder class for a dependency yet to be injected.</p> Source code in <code>src/tidi/decorator.py</code> <pre><code>class Unset(t.Any):\n\"\"\"Placeholder class for a dependency yet to be injected.\"\"\"\n</code></pre>"},{"location":"reference/decorator/#tidi.decorator.inject","title":"<code>inject(registry=None)</code>","text":"<p>A decorator that will replace certain keyword arguments with dependencies</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>Registry | None</code> <p>Provide a <code>tidi.registry.Registry</code> if you have one. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>typing.Callable[[typing.Callable[P, R]], typing.Callable[P, R]]</code> <p>The decorator itself.</p> <p>Examples:</p> <p>Define your own inject decorator if you don't want to use the top level package defined one.</p> <pre><code>&gt;&gt;&gt; # note: `new_injector` doesn't have a registry, which can be useful\n&gt;&gt;&gt; new_injector = tidi.decorator.inject()\n</code></pre> <p>Use the decorator just like the main one (<code>tidi.inject</code>)</p> <pre><code>&gt;&gt;&gt; @new_injector\n&gt;&gt;&gt; def create_db_connection(\n...    db_string: tidi.Injected = tidi.Provider(get_db_conn_string)\n... ) -&gt; db_library.DBConn:\n...     return db_library.connect(db_string)\n</code></pre> Source code in <code>src/tidi/decorator.py</code> <pre><code>def inject(registry: Registry | None = None) -&gt; t.Callable[[t.Callable[P, R]], t.Callable[P, R]]:\n\"\"\"A decorator that will replace certain keyword arguments with dependencies\n    Args:\n        registry (Registry | None, optional): Provide a `tidi.registry.Registry`\n            if you have one. Defaults to None.\n    Returns:\n        (t.Callable[[t.Callable[P, R]], t.Callable[P, R]]): The decorator itself.\n    Examples:\n        Define your own inject decorator if you don't want to use the top level\n        package defined one.\n        &gt;&gt;&gt; # note: `new_injector` doesn't have a registry, which can be useful\n        &gt;&gt;&gt; new_injector = tidi.decorator.inject()\n        Use the decorator just like the main one (`tidi.inject`)\n        &gt;&gt;&gt; @new_injector\n        &gt;&gt;&gt; def create_db_connection(\n        ...    db_string: tidi.Injected = tidi.Provider(get_db_conn_string)\n        ... ) -&gt; db_library.DBConn:\n        ...     return db_library.connect(db_string)\n    \"\"\"\ndef decorator(func: t.Callable[P, R]) -&gt; t.Callable[P, R]:\ninjectable_params = _get_injectable_parameters_from_func_signature(func)\n@functools.wraps(func)\ndef wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\nfor param in injectable_params:\nobj = resolver.resolve_dependency(\ntype_=param.base_type,\nresolver_options=next(metadata for metadata in param.annotated_metadata),\nregistry=registry,\nprovider=param.default.provider_func\nif isinstance(param.default, Provider)\nelse None,\n)\nkwargs.setdefault(param.name, obj)\nreturn func(*args, **kwargs)\nreturn wrapper\nreturn decorator\n</code></pre>"},{"location":"reference/parameters/","title":"Parameters module","text":"<p>Note: this is a helper module that isn't directly related to the Tidi API.</p>"},{"location":"reference/parameters/#tidi.parameters","title":"<code>tidi.parameters</code>","text":"<p>Extends functionality of <code>inspect.Parameter</code> to help work with <code>typing.Annotated</code> function parameters.</p>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameter","title":"<code>AnnotatedParameter</code>","text":"<p>             Bases: <code>Parameter</code></p> <p>Subclass of <code>inspect.Parameter</code> aimed for parameters with <code>typing.Annotated</code> type.</p> <p>Has extra properties that are useful when the type hint is <code>typing.Annotated</code>.</p> Source code in <code>src/tidi/parameters.py</code> <pre><code>class AnnotatedParameter(inspect.Parameter):\n\"\"\"Subclass of `inspect.Parameter` aimed for parameters with `typing.Annotated` type.\n    Has extra properties that are useful when the type hint is `typing.Annotated`.\n    \"\"\"\ndef __init__(\nself,\nname: str,\nkind: inspect._ParameterKind,\n*,\ndefault: t.Any = ...,\nannotation: t.Any = ...,\n) -&gt; None:\nsuper().__init__(name, kind, default=default, annotation=annotation)\n@classmethod\ndef from_parameter(cls, parameter: inspect.Parameter) -&gt; t.Self:\n\"\"\"Builds a `AnnotatedParameter` from a normal `inspect.Parameter`\n        Args:\n            parameter (inspect.Parameter): The normal `inspect.Parameter` to build from\n        Returns:\n            (AnnotatedParameter): the new `AnnotatedParameter` instance\n        \"\"\"\nreturn cls(\nname=parameter.name,\nkind=parameter.kind,\ndefault=parameter.default,\nannotation=parameter.annotation,\n)\n@property\ndef is_annotated_type(self) -&gt; bool:\n\"\"\"`True` if the origin type hint is `typing.Annotated`, otherwise `False`.\"\"\"\nreturn t.get_origin(self.annotation) is t.Annotated\n@property\ndef base_type(self) -&gt; t.Type:  # type: ignore\n\"\"\"The _real_ type of the `typing.Annotated` parameter.\"\"\"\nassert self.is_annotated_type\nmatch t.get_args(self.annotation)[0]:\ncase union if t.get_origin(union) in (t.Union, types.UnionType):\nreturn t.get_args(union)[0]\ncase base_type:\nreturn base_type\n@property\ndef annotated_metadata(self) -&gt; tuple:\n\"\"\"A tuple of the extra annotations added via the `typing.Annotated` hint.\"\"\"\nassert self.is_annotated_type\nreturn t.get_args(self.annotation)[1:]\n</code></pre>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameter.annotated_metadata","title":"<code>annotated_metadata: tuple</code>  <code>property</code>","text":"<p>A tuple of the extra annotations added via the <code>typing.Annotated</code> hint.</p>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameter.base_type","title":"<code>base_type: t.Type</code>  <code>property</code>","text":"<p>The real type of the <code>typing.Annotated</code> parameter.</p>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameter.is_annotated_type","title":"<code>is_annotated_type: bool</code>  <code>property</code>","text":"<p><code>True</code> if the origin type hint is <code>typing.Annotated</code>, otherwise <code>False</code>.</p>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameter.from_parameter","title":"<code>from_parameter(parameter)</code>  <code>classmethod</code>","text":"<p>Builds a <code>AnnotatedParameter</code> from a normal <code>inspect.Parameter</code></p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>Parameter</code> <p>The normal <code>inspect.Parameter</code> to build from</p> required <p>Returns:</p> Type Description <code>AnnotatedParameter</code> <p>the new <code>AnnotatedParameter</code> instance</p> Source code in <code>src/tidi/parameters.py</code> <pre><code>@classmethod\ndef from_parameter(cls, parameter: inspect.Parameter) -&gt; t.Self:\n\"\"\"Builds a `AnnotatedParameter` from a normal `inspect.Parameter`\n    Args:\n        parameter (inspect.Parameter): The normal `inspect.Parameter` to build from\n    Returns:\n        (AnnotatedParameter): the new `AnnotatedParameter` instance\n    \"\"\"\nreturn cls(\nname=parameter.name,\nkind=parameter.kind,\ndefault=parameter.default,\nannotation=parameter.annotation,\n)\n</code></pre>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameters","title":"<code>AnnotatedParameters</code>","text":"<p>             Bases: <code>list[AnnotatedParameter]</code></p> <p>A list of <code>AnnotatedParameter</code> instances.</p> Source code in <code>src/tidi/parameters.py</code> <pre><code>class AnnotatedParameters(list[AnnotatedParameter]):\n\"\"\"A list of `AnnotatedParameter` instances.\"\"\"\ndef __init__(self, values: t.Iterable):\nsuper().__init__(values)\n@classmethod\ndef from_func(cls, func: t.Callable) -&gt; t.Self:\n\"\"\"Builds `AnnotatedParameters` by inspecting a function's signature.\"\"\"\nreturn cls(\nann_param\nfor param in inspect.signature(func).parameters.values()\nif (ann_param := AnnotatedParameter.from_parameter(param)).is_annotated_type\n)\n</code></pre>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameters.from_func","title":"<code>from_func(func)</code>  <code>classmethod</code>","text":"<p>Builds <code>AnnotatedParameters</code> by inspecting a function's signature.</p> Source code in <code>src/tidi/parameters.py</code> <pre><code>@classmethod\ndef from_func(cls, func: t.Callable) -&gt; t.Self:\n\"\"\"Builds `AnnotatedParameters` by inspecting a function's signature.\"\"\"\nreturn cls(\nann_param\nfor param in inspect.signature(func).parameters.values()\nif (ann_param := AnnotatedParameter.from_parameter(param)).is_annotated_type\n)\n</code></pre>"},{"location":"reference/registry/","title":"Registry module","text":""},{"location":"reference/registry/#tidi.registry","title":"<code>tidi.registry</code>","text":"<p>Provides a <code>TidiRegistry</code>, responsible for providing stored dependencies.</p>"},{"location":"reference/registry/#tidi.registry.RegistrationError","title":"<code>RegistrationError</code>","text":"<p>             Bases: <code>TypeError</code></p> <p>Error finding desired type in registry</p> Source code in <code>src/tidi/registry.py</code> <pre><code>class RegistrationError(TypeError):\n\"\"\"Error finding desired type in registry\"\"\"\n</code></pre>"},{"location":"reference/registry/#tidi.registry.RegistryLookupError","title":"<code>RegistryLookupError</code>","text":"<p>             Bases: <code>LookupError</code></p> <p>Error finding desired type in registry</p> Source code in <code>src/tidi/registry.py</code> <pre><code>class RegistryLookupError(LookupError):\n\"\"\"Error finding desired type in registry\"\"\"\n</code></pre>"},{"location":"reference/registry/#tidi.registry.TidiRegistry","title":"<code>TidiRegistry</code>","text":"<p>A simple registry of objects indexed by their type.</p> Source code in <code>src/tidi/registry.py</code> <pre><code>class TidiRegistry:\n\"\"\"A simple registry of objects indexed by their type.\"\"\"\ndef __init__(self, banned_types: list[t.Type] | None = None):\nif banned_types is None:\nbanned_types = [\ntype_ for type_ in builtins.__dict__.values() if isinstance(type_, type)\n]\nself.banned_types = banned_types\nself._registry: dict = {}\ndef register(self, obj: t.Any):\n\"\"\"Register an instance `obj` of class `T` to be available for injection.\n        Args:\n            obj (typing.Any): The instance to register\n        Raises:\n            RegistrationError: if trying to register a banned type (a builtin type by default).\n        \"\"\"\ntype_ = type(obj)\nif type_ in self.banned_types:\nraise RegistrationError(f\"Trying to register a banned type: {type_}\")\nself._registry[type_] = obj\ndef get(self, type_: t.Type[T], default: t.Any = _unknown) -&gt; T:\n\"\"\"Get an instance of type `type_` from the regsitry.\n        Args:\n            type_ (t.Type[T]): The type of the dependency being looked for.\n            default (t.Any, optional): An optional default return value.\n        Raises:\n            RegistryLookupError: if the instance hasn't been registered and a\n                default hasn't been provided.\n        Returns:\n            (type_ (T)): the registered object, or default value if it was provided.\n        \"\"\"\nobj = self._registry.get(type_, default)\nif isinstance(obj, _Unknown):\nraise RegistryLookupError(f\"Type has not been registered: {type_}\")\nreturn obj\n</code></pre>"},{"location":"reference/registry/#tidi.registry.TidiRegistry.get","title":"<code>get(type_, default=_unknown)</code>","text":"<p>Get an instance of type <code>type_</code> from the regsitry.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>typing.Type[T]</code> <p>The type of the dependency being looked for.</p> required <code>default</code> <code>Any</code> <p>An optional default return value.</p> <code>_unknown</code> <p>Raises:</p> Type Description <code>RegistryLookupError</code> <p>if the instance hasn't been registered and a default hasn't been provided.</p> <p>Returns:</p> Type Description <code>type_(T)</code> <p>the registered object, or default value if it was provided.</p> Source code in <code>src/tidi/registry.py</code> <pre><code>def get(self, type_: t.Type[T], default: t.Any = _unknown) -&gt; T:\n\"\"\"Get an instance of type `type_` from the regsitry.\n    Args:\n        type_ (t.Type[T]): The type of the dependency being looked for.\n        default (t.Any, optional): An optional default return value.\n    Raises:\n        RegistryLookupError: if the instance hasn't been registered and a\n            default hasn't been provided.\n    Returns:\n        (type_ (T)): the registered object, or default value if it was provided.\n    \"\"\"\nobj = self._registry.get(type_, default)\nif isinstance(obj, _Unknown):\nraise RegistryLookupError(f\"Type has not been registered: {type_}\")\nreturn obj\n</code></pre>"},{"location":"reference/registry/#tidi.registry.TidiRegistry.register","title":"<code>register(obj)</code>","text":"<p>Register an instance <code>obj</code> of class <code>T</code> to be available for injection.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The instance to register</p> required <p>Raises:</p> Type Description <code>RegistrationError</code> <p>if trying to register a banned type (a builtin type by default).</p> Source code in <code>src/tidi/registry.py</code> <pre><code>def register(self, obj: t.Any):\n\"\"\"Register an instance `obj` of class `T` to be available for injection.\n    Args:\n        obj (typing.Any): The instance to register\n    Raises:\n        RegistrationError: if trying to register a banned type (a builtin type by default).\n    \"\"\"\ntype_ = type(obj)\nif type_ in self.banned_types:\nraise RegistrationError(f\"Trying to register a banned type: {type_}\")\nself._registry[type_] = obj\n</code></pre>"},{"location":"reference/resolver/","title":"Resolver module","text":""},{"location":"reference/resolver/#tidi.resolver","title":"<code>tidi.resolver</code>","text":"<p>Finds or creates dependency instances based on availability and options.</p>"},{"location":"reference/resolver/#tidi.resolver.DependencyResolutionError","title":"<code>DependencyResolutionError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Unable to resolve dependency</p> Source code in <code>src/tidi/resolver.py</code> <pre><code>class DependencyResolutionError(Exception):\n\"\"\"Unable to resolve dependency\"\"\"\n</code></pre>"},{"location":"reference/resolver/#tidi.resolver.ResolverOptions","title":"<code>ResolverOptions</code>  <code>dataclass</code>","text":"<p>Options that control how resolving is done.</p> <p>Parameters:</p> Name Type Description Default <code>use_registry</code> <code>bool</code> <p>whether to try using the registry or not.</p> required <code>initialise_missing</code> <code>bool</code> <p>whether to try to initialise the dependency or not.</p> required Source code in <code>src/tidi/resolver.py</code> <pre><code>@dataclass(frozen=True)\nclass ResolverOptions:\n\"\"\"Options that control how resolving is done.\n    Args:\n        use_registry (bool): whether to try using the registry or not.\n        initialise_missing (bool): whether to try to initialise the dependency or not.\n    \"\"\"\nuse_registry: bool\ninitialise_missing: bool\n</code></pre>"},{"location":"reference/resolver/#tidi.resolver.resolve_dependency","title":"<code>resolve_dependency(type_, resolver_options, registry=None, provider=None)</code>","text":"<p>Returns a dependency according to configured options.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>typing.Type[T]</code> <p>the type of the dependency being looked for.</p> required <code>resolver_options</code> <code>ResolverOptions</code> <p>options dictating how to resolve the dependency.</p> required <code>registry</code> <code>Registry | None</code> <p>an optional registry containing the dependency. Defaults to None.</p> <code>None</code> <code>provider</code> <code>typing.Callable[..., T] | None</code> <p>an optional function that will return the dependency. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>DependencyResolutionError</code> <p>if a registry is required but not provided</p> <code>DependencyResolutionError</code> <p>if the function doesn't know how to handle the situation</p> <p>Returns:</p> Type Description <code>type requested (T)</code> <p>an instance of the dependency requested.</p> Source code in <code>src/tidi/resolver.py</code> <pre><code>def resolve_dependency(\ntype_: t.Type[T],\nresolver_options: ResolverOptions,\nregistry: Registry | None = None,\nprovider: t.Callable[..., T] | None = None,\n) -&gt; T:\n\"\"\"Returns a dependency according to configured options.\n    Args:\n        type_ (typing.Type[T]): the type of the dependency being looked for.\n        resolver_options (ResolverOptions): options dictating how to resolve\n            the dependency.\n        registry (Registry | None, optional): an optional registry containing\n            the dependency. Defaults to None.\n        provider (typing.Callable[..., T] | None, optional): an optional\n            function that will return the dependency. Defaults to None.\n    Raises:\n        DependencyResolutionError: if a registry is required but not provided\n        DependencyResolutionError: if the function doesn't know how to handle the situation\n    Returns:\n        (type requested (T)): an instance of the dependency requested.\n    \"\"\"\nmatch resolver_options:\ncase ResolverOptions(use_registry=True, initialise_missing=False) if registry is not None:\nreturn registry.get(type_)\ncase ResolverOptions(use_registry=True, initialise_missing=False) if registry is None:\nraise DependencyResolutionError(\"Registry required but not provided.\")\ncase ResolverOptions(use_registry=True, initialise_missing=True) if registry is not None:\nobj = registry.get(type_, None)\nreturn obj if obj is not None else _initialise_dependency(type_, provider)\ncase ResolverOptions(initialise_missing=True) if registry is None:\nreturn _initialise_dependency(type_, provider)\nraise DependencyResolutionError(\"Unable to resolve dependency.\")\n</code></pre>"}]}