{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the Tidi documentation.</p> <p>Tidi is a small dependency injection Python\u00a0library.</p> <p>It's aim, apart from being a learning outcome of the author, is to provide a clean, type checker compliant, API for medium sized projects to benefit from Inversion of Control (IoC) through applying Dependency Injection (DI) without having to adopt a large DI framework.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install tidi\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#example-usage","title":"Example usage","text":"<pre><code>import tidi\n\nfrom my_package.auth import AuthError, AuthService\nfrom my_package.db import DBSession, QueuedJob, create_db_session\nfrom my_package.job import Job, JobQueue\n\n@tidi.inject\ndef process_job(\n  job: Job,\n  db_session: tidi.Injected[DBSession] = tidi.Provider(create_db_session)\n  auth_service: tidi.Injected[AuthService] = tidi.UNSET,\n):\n  if not auth_service.is_logged_in_user_authorised_for_job(job.name):\n    raise AuthError(\"Unauthorised to run this job :(\")\n  job.run(db_session=db_session)\n\n@tidi.inject\nclass JobQueue:\n  def __init__(\n    self,\n    db_session: tidi.Injected[DBSession] = tidi.Provider(create_db_session)\n  ):\n  self.jobs = db_session.query(QueuedJob).all()\n\ndef init_app():\n  auth_service = AuthService()\n  auth_service.log_in_user()\n  tidi.register(auth_service)\n\ndef main():\n  init_app()\n  for job in JobQueue().jobs:  # \ud83e\ude84 `DBSession` injected into `JobQueue` \u2728\n    process_job(job)  # \ud83e\ude84 `DBSession` and `AuthService` injected into `process_job` \u2728\n\nif __name__ == \"__main__\":\n  main()\n</code></pre> <p>Or see more examples in the <code>demo/</code> directory of the repo.</p>"},{"location":"#further-documentation-of-use","title":"Further documentation of use","text":"<p>See the Usage guide for more details</p>"},{"location":"#motivation","title":"Motivation","text":"<p>I found myself wanting to learn more about how DI can be done in a pythonic way, with type-hinting, so had the itch to develop (yet another) library for it and share it as open source \ud83e\uddd1\u200d\ud83d\udcbb\u270c\ufe0f</p> <p>My main inspiration was Kent Tong's disl and FastAPI's <code>Depends</code>.</p>"},{"location":"#contribution-guide","title":"Contribution guide","text":"<p>If you'd like to contribute to the development of Tidi, please clone the repo and read the CONTRIBUTING.md</p>"},{"location":"usage/","title":"Usage","text":"<p>There are a few main ways it's intended to be used.</p>"},{"location":"usage/#examples-of-usage","title":"Examples of usage","text":""},{"location":"usage/#inject-a-dependency-that-has-been-put-in-a-registry","title":"Inject a dependency that has been put in a\u00a0registry","text":"<pre><code>import tidi\n\n@tidi.inject\ndef run(auth: tidi.Injected[AuthService] = tidi.UNSET):\n    if auth.is_super_user():\n        logger.info(f\"Running with elevated permissions.\")\n    ...\n\nif __name__ == \"__main__\":\n    tidi.register(AuthService())\n\n    ...\n\n    run()  # \ud83e\ude84 `AuthService` injected into `run` \u2728\n</code></pre>"},{"location":"usage/#inject-a-dependency-provided-by-a-function","title":"Inject a dependency provided by a\u00a0function","text":"<pre><code>import tidi\n\ndef get_secret() -&gt; str:\n    return \"wshwshwhswhs\"\n\n@tidi.inject\ndef run(secret: tidi.Injected[str] = tidi.Provider(get_secret)):\n    logger.info(f\"don't tell anyone this but, {secret}\")\n\nif __name__ == \"__main__\":\n    run()  # \ud83e\ude84 result from `get_secret()` injected into `run` \u2728\n</code></pre>"},{"location":"usage/#or-provided-by-instantiating-a-class","title":"Or provided by instantiating a\u00a0class","text":"<pre><code>import tidi\n\nclass SnackRepo():\n    def __init__(self, db_string = \"fridge\"):\n        self.db_string = db_string\n\n    def get_snack(self):\n        return f\"snack, out of the {self.db_string}\"\n\n@tidi.inject\ndef eat_snack(repo: tidi.Injected[SnackRepo] = tidi.Provider(SnackRepo)):\n    logger.info(f\"eating {repo.get_snack()}\")\n\nif __name__ == \"__main__\":\n    eat_snack()  # \ud83e\ude84 a new `SnackRepo` injected into `run` \u2728\n</code></pre>"},{"location":"usage/#the-injection-also-works-with-classes-either-into-the-constructor","title":"The injection also works with classes, either into the constructor","text":"<pre><code>import tidi\n\n@tidi.inject\nclass Algorithm:\n    def __init__(self, config: tidi.Injected[Config] = tidi.UNSET):\n        self.tolerance = config.tolerance\n\n    def run(self, input_value: float) -&gt; float:\n        return input_value - input_value * self.tolerance\n\nif __name__ == \"__main__\":\n    tidi.register(Config(tolerance=0.1))\n    alg = Algorithm()  # \ud83e\ude84 `Config` injected into new `Algorithm` instance \u2728\n    alg.run(10.0)\n</code></pre>"},{"location":"usage/#or-into-their-methods","title":"Or into their\u00a0methods","text":"<pre><code>import tidi\n\nclass Job:\n    def __init__(self, name):\n        self.name = name\n\n    @tidi.inject\n    def run(self, db: tidi.Injected[DBConnection] = tidi.Provider(get_db_conn)):\n        logger.info(f\"run job {self.name} using database {db.name}\")\n\nif __name__ == \"__main__\":\n    job = Job(\"new job\")\n    job.run()  # \ud83e\ude84 `DBConnection` injected into `job.run` \u2728\n</code></pre>"},{"location":"usage/#and-to-inject-dependencies-into-a-dataclass-use-the-field_factory","title":"And to inject dependencies into a dataclass, use the field_factory","text":"<pre><code>from dataclasses import dataclass, field\n\nimport tidi\n\n@dataclass\nclass Output:\n    value: float\n    created_by: User = field(default_factory=tidi.field_factory(User))\n\ndef process_next_job():\n    return Output(value=1)  # \ud83e\ude84 `User` injected into `Output.created_by` \u2728\n\nif __name__ == \"__main__\":\n    current_user = User.from_env_credentials()\n    tidi.register(current_user)\n    output = process_next_job()\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#main-api","title":"Main API","text":"<p>The top level import of <code>tidi</code> provides everything needed it's primary intended use.</p> <ul> <li><code>tidi.inject</code> - a decorator that will replace certain keyword arguments with dependencies, based on their type &amp; if they haven't been passed in</li> <li><code>tidi.Injected</code> - a type alias, wrapping <code>typing.Annotated</code>, that indicates that a keyword argument should be injected</li> <li><code>tidi.register</code> - a function that registers an object to be available for injection as a dependency</li> <li><code>tidi.Provider</code> - a wrapper class around a function that will be called to provide a dependency</li> <li><code>tidi.UNSET</code> - a sentinel object to indicate that a dependency should be loaded from the registry</li> <li><code>tidi.field_factory</code> - a helper function for injecting dependencies into dataclass fields</li> </ul>"},{"location":"reference/#tidiinject-tidiinjected-tidiunset","title":"<code>tidi.inject</code>, <code>tidi.Injected</code>, &amp; <code>tidi.UNSET</code>","text":"<p><code>@tidi.inject</code> will injects dependencies into keyword arguments with the <code>tidi.Injected</code> type annotation.</p> <p>If the default value is <code>tidi.UNSET</code>, it will search for that dependency in the registry.</p> <pre><code>@tidi.inject\ndef get_users(db: tidi.Injected[Database] = tidi.UNSET):\n    db.query(Users).all()\n</code></pre> <p>See the <code>tidi.decorator</code> documentation for more detail.</p>"},{"location":"reference/#tidiregister","title":"<code>tidi.register</code>","text":"<p>To register a dependency instance, simple call the <code>tidi.register</code> function</p> <pre><code>database = load_database()\ntidi.register(database)\n</code></pre> <p>This puts it into the default registry which is shared across</p> <p>See the <code>tidi.registry</code> documentation for more detail.</p>"},{"location":"reference/#tidiprovider","title":"<code>tidi.Provider</code>","text":"<p>For more control over what instance is injected, use the provider function.</p> <p>The elected provider function will be called each time the function is called.</p> <pre><code>@tidi.inject\ndef get_users(db: tidi.Injected[Database] = tidi.Provider(load_database)):\n    db.query(Users).all()\n</code></pre> <p>See the <code>tidi.decorator</code> documentation for more detail.</p>"},{"location":"reference/#tidifield_factory","title":"<code>tidi.field_factory</code>","text":"<p>When working with dataclasses, the <code>inject</code> decorator doesn't work, so use the <code>field_factory</code> convenience function to inject the dependency into a field upon instance creation.</p> <pre><code>from dataclasses import dataclass, field\n\n@dataclass\nclass UserQuery:\n    name: str\n    db: Database = field(default_factory=tidi.field_factory(Database))\n\nuser_query = UserQuery()\nexecute_user_query(user_query)\n</code></pre>"},{"location":"reference/#modules","title":"Modules","text":"<p>Tidi's codebase consists of the following four, relatively small modules:</p> <ul> <li><code>tidi.decorator</code> - provides the main inject decorator, using <code>tidi.parameters</code> to determine which parameters of the wrapped function to replace</li> <li><code>tidi.parameters</code> - background wrapper of the builtin <code>inspect.Parameter</code> class for determining which function parameters are annotated</li> <li><code>tidi.registry</code> - provides simple registry class for holding dependency instances, stored in a dictionary (map), using their type as the key</li> <li><code>tidi.resolver</code> - contains the logic used to either find an object from the registry or from a provider function</li> </ul>"},{"location":"reference/decorator/","title":"Decorator module","text":""},{"location":"reference/decorator/#tidi.decorator","title":"<code>tidi.decorator</code>","text":"<p>Provides the main <code>inject</code> decorator.</p> <p>Uses <code>tidi.parameters</code> to determine which parameters of the wrapped function to replace.</p>"},{"location":"reference/decorator/#tidi.decorator.UNSET","title":"<code>UNSET = Unset()</code>  <code>module-attribute</code>","text":"<p>Sentinel <code>Unset</code> object used to indicate a kwarg is not set yet.</p>"},{"location":"reference/decorator/#tidi.decorator.Provider","title":"<code>Provider</code>","text":"<p>             Bases: <code>Generic[T]</code>, <code>Any</code></p> <p>Wrapper class around a function that will be called to provide a dependency</p> <p>Parameters:</p> Name Type Description Default <code>provider_func</code> <code>Callable</code> <p>Callable that will return a given type (TypeVar <code>T</code>) which will be used as the dependency.</p> required <p>Examples:</p> <p>Define a provider function</p> <pre><code>&gt;&gt;&gt; def get_big_toolbox() -&gt; Toolbox:\n&gt;&gt;&gt;     return ...\n</code></pre> <p>Give the provider function into the kwarg marked for injected</p> <pre><code>&gt;&gt;&gt; @tidi.inject\n... def get_hammers(\n...     toolbox: tidi.Injected[Toolbox] = tidi.Provider(get_big_toolbox)\n... ) -&gt; list[Hammer]:\n...     return [tool for tool in toolbox.tools if isinstance(tool, Hammer)]\n</code></pre> <p>Now when you call <code>get_hammers</code>, Tidi will call <code>get_big_toolbox</code> and inject it into the <code>toolbox</code> kwarg</p> <pre><code>&gt;&gt;&gt; get_hammers()\n</code></pre> Source code in <code>src/tidi/decorator.py</code> <pre><code>class Provider(t.Generic[T], t.Any):  # inherit from Any to appease type checkers\n    \"\"\"Wrapper class around a function that will be called to provide a dependency\n\n    Args:\n        provider_func (typing.Callable): Callable that will return a given\n            type (TypeVar `T`) which will be used as the dependency.\n\n    Examples:\n        Define a provider function\n        &gt;&gt;&gt; def get_big_toolbox() -&gt; Toolbox:\n        &gt;&gt;&gt;     return ...\n\n        Give the provider function into the kwarg marked for injected\n        &gt;&gt;&gt; @tidi.inject\n        ... def get_hammers(\n        ...     toolbox: tidi.Injected[Toolbox] = tidi.Provider(get_big_toolbox)\n        ... ) -&gt; list[Hammer]:\n        ...     return [tool for tool in toolbox.tools if isinstance(tool, Hammer)]\n\n        Now when you call `get_hammers`, Tidi will call `get_big_toolbox` and\n        inject it into the `toolbox` kwarg\n        &gt;&gt;&gt; get_hammers()\n    \"\"\"\n\n    # overloading new to avoid issue with the `Any` inheritance\n    @classmethod\n    def __new__(cls, *args, **kwargs) -&gt; t.Self:\n        return super().__new__(cls)\n\n    def __init__(self, provider_func: t.Callable[..., T]):\n        self.provider_func = provider_func\n</code></pre>"},{"location":"reference/decorator/#tidi.decorator.Unset","title":"<code>Unset</code>","text":"<p>             Bases: <code>Any</code></p> <p>Placeholder class for a dependency yet to be injected.</p> Source code in <code>src/tidi/decorator.py</code> <pre><code>class Unset(t.Any):\n    \"\"\"Placeholder class for a dependency yet to be injected.\"\"\"\n</code></pre>"},{"location":"reference/decorator/#tidi.decorator.inject","title":"<code>inject(registry=None)</code>","text":"<p>A decorator that will replace certain keyword arguments with dependencies</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>Registry | None</code> <p>Provide a <code>tidi.registry.Registry</code> if you have one. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>The decorator itself.</p> <p>Examples:</p> <p>Define your own inject decorator if you don't want to use the top level package defined one.</p> <pre><code>&gt;&gt;&gt; # note: `new_injector` doesn't have a registry, which can be useful\n&gt;&gt;&gt; new_injector = tidi.decorator.inject()\n</code></pre> <p>Use the decorator just like the main one (<code>tidi.inject</code>)</p> <pre><code>&gt;&gt;&gt; @new_injector\n&gt;&gt;&gt; def create_db_connection(\n...    db_string: tidi.Injected = tidi.Provider(get_db_conn_string)\n... ) -&gt; db_library.DBConn:\n...     return db_library.connect(db_string)\n</code></pre> Source code in <code>src/tidi/decorator.py</code> <pre><code>def inject(registry: Registry | None = None) -&gt; t.Callable[[t.Callable[P, R]], t.Callable[P, R]]:\n    \"\"\"A decorator that will replace certain keyword arguments with dependencies\n\n    Args:\n        registry (Registry | None, optional): Provide a `tidi.registry.Registry`\n            if you have one. Defaults to None.\n\n    Returns:\n        (t.Callable[[t.Callable[P, R]], t.Callable[P, R]]): The decorator itself.\n\n    Examples:\n        Define your own inject decorator if you don't want to use the top level\n        package defined one.\n        &gt;&gt;&gt; # note: `new_injector` doesn't have a registry, which can be useful\n        &gt;&gt;&gt; new_injector = tidi.decorator.inject()\n\n        Use the decorator just like the main one (`tidi.inject`)\n        &gt;&gt;&gt; @new_injector\n        &gt;&gt;&gt; def create_db_connection(\n        ...    db_string: tidi.Injected = tidi.Provider(get_db_conn_string)\n        ... ) -&gt; db_library.DBConn:\n        ...     return db_library.connect(db_string)\n    \"\"\"\n\n    def decorator(func: t.Callable[P, R]) -&gt; t.Callable[P, R]:\n        injectable_params = _get_injectable_parameters_from_func_signature(func)\n\n        @functools.wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            for param in injectable_params:\n                obj = resolver.resolve_dependency(\n                    type_=param.base_type,\n                    resolver_options=next(metadata for metadata in param.annotated_metadata),\n                    registry=registry,\n                    provider=param.default.provider_func\n                    if isinstance(param.default, Provider)\n                    else None,\n                )\n                kwargs.setdefault(param.name, obj)\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/parameters/","title":"Parameters module","text":"<p>Note: this is a helper module that isn't directly related to the Tidi API.</p>"},{"location":"reference/parameters/#tidi.parameters","title":"<code>tidi.parameters</code>","text":"<p>Extends functionality of <code>inspect.Parameter</code> to help work with <code>typing.Annotated</code> function parameters.</p>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameter","title":"<code>AnnotatedParameter</code>","text":"<p>             Bases: <code>Parameter</code></p> <p>Subclass of <code>inspect.Parameter</code> aimed for parameters with <code>typing.Annotated</code> type.</p> <p>Has extra properties that are useful when the type hint is <code>typing.Annotated</code>.</p> Source code in <code>src/tidi/parameters.py</code> <pre><code>class AnnotatedParameter(inspect.Parameter):\n    \"\"\"Subclass of `inspect.Parameter` aimed for parameters with `typing.Annotated` type.\n\n    Has extra properties that are useful when the type hint is `typing.Annotated`.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        kind: inspect._ParameterKind,\n        *,\n        default: t.Any = ...,\n        annotation: t.Any = ...,\n    ) -&gt; None:\n        super().__init__(name, kind, default=default, annotation=annotation)\n\n    @classmethod\n    def from_parameter(cls, parameter: inspect.Parameter) -&gt; t.Self:\n        \"\"\"Builds a `AnnotatedParameter` from a normal `inspect.Parameter`\n\n        Args:\n            parameter (inspect.Parameter): The normal `inspect.Parameter` to build from\n\n        Returns:\n            (AnnotatedParameter): the new `AnnotatedParameter` instance\n        \"\"\"\n        return cls(\n            name=parameter.name,\n            kind=parameter.kind,\n            default=parameter.default,\n            annotation=parameter.annotation,\n        )\n\n    @property\n    def is_annotated_type(self) -&gt; bool:\n        \"\"\"`True` if the origin type hint is `typing.Annotated`, otherwise `False`.\"\"\"\n        return t.get_origin(self.annotation) is t.Annotated\n\n    @property\n    def base_type(self) -&gt; t.Type:  # type: ignore\n        \"\"\"The _real_ type of the `typing.Annotated` parameter.\"\"\"\n        assert self.is_annotated_type\n        match t.get_args(self.annotation)[0]:\n            case union if t.get_origin(union) in (t.Union, types.UnionType):\n                return t.get_args(union)[0]\n            case base_type:\n                return base_type\n\n    @property\n    def annotated_metadata(self) -&gt; tuple:\n        \"\"\"A tuple of the extra annotations added via the `typing.Annotated` hint.\"\"\"\n        assert self.is_annotated_type\n        return t.get_args(self.annotation)[1:]\n</code></pre>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameter.annotated_metadata","title":"<code>annotated_metadata: tuple</code>  <code>property</code>","text":"<p>A tuple of the extra annotations added via the <code>typing.Annotated</code> hint.</p>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameter.base_type","title":"<code>base_type: t.Type</code>  <code>property</code>","text":"<p>The real type of the <code>typing.Annotated</code> parameter.</p>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameter.is_annotated_type","title":"<code>is_annotated_type: bool</code>  <code>property</code>","text":"<p><code>True</code> if the origin type hint is <code>typing.Annotated</code>, otherwise <code>False</code>.</p>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameter.from_parameter","title":"<code>from_parameter(parameter)</code>  <code>classmethod</code>","text":"<p>Builds a <code>AnnotatedParameter</code> from a normal <code>inspect.Parameter</code></p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>Parameter</code> <p>The normal <code>inspect.Parameter</code> to build from</p> required <p>Returns:</p> Type Description <code>AnnotatedParameter</code> <p>the new <code>AnnotatedParameter</code> instance</p> Source code in <code>src/tidi/parameters.py</code> <pre><code>@classmethod\ndef from_parameter(cls, parameter: inspect.Parameter) -&gt; t.Self:\n    \"\"\"Builds a `AnnotatedParameter` from a normal `inspect.Parameter`\n\n    Args:\n        parameter (inspect.Parameter): The normal `inspect.Parameter` to build from\n\n    Returns:\n        (AnnotatedParameter): the new `AnnotatedParameter` instance\n    \"\"\"\n    return cls(\n        name=parameter.name,\n        kind=parameter.kind,\n        default=parameter.default,\n        annotation=parameter.annotation,\n    )\n</code></pre>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameters","title":"<code>AnnotatedParameters</code>","text":"<p>             Bases: <code>list[AnnotatedParameter]</code></p> <p>A list of <code>AnnotatedParameter</code> instances.</p> Source code in <code>src/tidi/parameters.py</code> <pre><code>class AnnotatedParameters(list[AnnotatedParameter]):\n    \"\"\"A list of `AnnotatedParameter` instances.\"\"\"\n\n    def __init__(self, values: t.Iterable):\n        super().__init__(values)\n\n    @classmethod\n    def from_func(cls, func: t.Callable) -&gt; t.Self:\n        \"\"\"Builds `AnnotatedParameters` by inspecting a function's signature.\"\"\"\n        return cls(\n            ann_param\n            for param in inspect.signature(func).parameters.values()\n            if (ann_param := AnnotatedParameter.from_parameter(param)).is_annotated_type\n        )\n</code></pre>"},{"location":"reference/parameters/#tidi.parameters.AnnotatedParameters.from_func","title":"<code>from_func(func)</code>  <code>classmethod</code>","text":"<p>Builds <code>AnnotatedParameters</code> by inspecting a function's signature.</p> Source code in <code>src/tidi/parameters.py</code> <pre><code>@classmethod\ndef from_func(cls, func: t.Callable) -&gt; t.Self:\n    \"\"\"Builds `AnnotatedParameters` by inspecting a function's signature.\"\"\"\n    return cls(\n        ann_param\n        for param in inspect.signature(func).parameters.values()\n        if (ann_param := AnnotatedParameter.from_parameter(param)).is_annotated_type\n    )\n</code></pre>"},{"location":"reference/registry/","title":"Registry module","text":""},{"location":"reference/registry/#tidi.registry","title":"<code>tidi.registry</code>","text":"<p>Provides a <code>TidiRegistry</code>, responsible for providing stored dependencies.</p>"},{"location":"reference/registry/#tidi.registry.RegistrationError","title":"<code>RegistrationError</code>","text":"<p>             Bases: <code>TypeError</code></p> <p>Error finding desired type in registry</p> Source code in <code>src/tidi/registry.py</code> <pre><code>class RegistrationError(TypeError):\n    \"\"\"Error finding desired type in registry\"\"\"\n</code></pre>"},{"location":"reference/registry/#tidi.registry.RegistryLookupError","title":"<code>RegistryLookupError</code>","text":"<p>             Bases: <code>LookupError</code></p> <p>Error finding desired type in registry</p> Source code in <code>src/tidi/registry.py</code> <pre><code>class RegistryLookupError(LookupError):\n    \"\"\"Error finding desired type in registry\"\"\"\n</code></pre>"},{"location":"reference/registry/#tidi.registry.TidiRegistry","title":"<code>TidiRegistry</code>","text":"<p>A simple registry of objects indexed by their type.</p> Source code in <code>src/tidi/registry.py</code> <pre><code>class TidiRegistry:\n    \"\"\"A simple registry of objects indexed by their type.\"\"\"\n\n    def __init__(\n        self,\n        banned_types: list[t.Type] | None = None,\n        container_cls: t.Type[_Container] = _PerThreadContainer,\n    ):\n        if banned_types is None:\n            banned_types = [\n                type_ for type_ in builtins.__dict__.values() if isinstance(type_, type)\n            ]\n        self.banned_types = banned_types\n        self._container = container_cls()\n\n    def register(self, obj: t.Any):\n        \"\"\"Register an instance `obj` of class `T` to be available for injection.\n\n        Args:\n            obj (typing.Any): The instance to register\n\n        Raises:\n            RegistrationError: if trying to register a banned type (a builtin type by default).\n        \"\"\"\n        type_ = type(obj)\n        if type_ in self.banned_types:\n            raise RegistrationError(f\"Trying to register a banned type: {type_}\")\n        self._container.add(obj)\n\n    def get(self, type_: t.Type[T], default: t.Any = _unknown) -&gt; T:\n        \"\"\"Get an instance of type `type_` from the regsitry.\n\n        Args:\n            type_ (t.Type[T]): The type of the dependency being looked for.\n            default (t.Any, optional): An optional default return value.\n\n        Raises:\n            RegistryLookupError: if the instance hasn't been registered and a\n                default hasn't been provided.\n\n        Returns:\n            (type_ (T)): the registered object, or default value if it was provided.\n        \"\"\"\n        obj = self._container.get(type_, default)\n        if isinstance(obj, _Unknown):\n            raise RegistryLookupError(f\"Type has not been registered: {type_}\")\n        return obj\n</code></pre>"},{"location":"reference/registry/#tidi.registry.TidiRegistry.get","title":"<code>get(type_, default=_unknown)</code>","text":"<p>Get an instance of type <code>type_</code> from the regsitry.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>Type[T]</code> <p>The type of the dependency being looked for.</p> required <code>default</code> <code>Any</code> <p>An optional default return value.</p> <code>_unknown</code> <p>Raises:</p> Type Description <code>RegistryLookupError</code> <p>if the instance hasn't been registered and a default hasn't been provided.</p> <p>Returns:</p> Type Description <code>type_(T)</code> <p>the registered object, or default value if it was provided.</p> Source code in <code>src/tidi/registry.py</code> <pre><code>def get(self, type_: t.Type[T], default: t.Any = _unknown) -&gt; T:\n    \"\"\"Get an instance of type `type_` from the regsitry.\n\n    Args:\n        type_ (t.Type[T]): The type of the dependency being looked for.\n        default (t.Any, optional): An optional default return value.\n\n    Raises:\n        RegistryLookupError: if the instance hasn't been registered and a\n            default hasn't been provided.\n\n    Returns:\n        (type_ (T)): the registered object, or default value if it was provided.\n    \"\"\"\n    obj = self._container.get(type_, default)\n    if isinstance(obj, _Unknown):\n        raise RegistryLookupError(f\"Type has not been registered: {type_}\")\n    return obj\n</code></pre>"},{"location":"reference/registry/#tidi.registry.TidiRegistry.register","title":"<code>register(obj)</code>","text":"<p>Register an instance <code>obj</code> of class <code>T</code> to be available for injection.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The instance to register</p> required <p>Raises:</p> Type Description <code>RegistrationError</code> <p>if trying to register a banned type (a builtin type by default).</p> Source code in <code>src/tidi/registry.py</code> <pre><code>def register(self, obj: t.Any):\n    \"\"\"Register an instance `obj` of class `T` to be available for injection.\n\n    Args:\n        obj (typing.Any): The instance to register\n\n    Raises:\n        RegistrationError: if trying to register a banned type (a builtin type by default).\n    \"\"\"\n    type_ = type(obj)\n    if type_ in self.banned_types:\n        raise RegistrationError(f\"Trying to register a banned type: {type_}\")\n    self._container.add(obj)\n</code></pre>"},{"location":"reference/resolver/","title":"Resolver module","text":""},{"location":"reference/resolver/#tidi.resolver","title":"<code>tidi.resolver</code>","text":"<p>Finds or creates dependency instances based on availability and options.</p>"},{"location":"reference/resolver/#tidi.resolver.DependencyResolutionError","title":"<code>DependencyResolutionError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Unable to resolve dependency</p> Source code in <code>src/tidi/resolver.py</code> <pre><code>class DependencyResolutionError(Exception):\n    \"\"\"Unable to resolve dependency\"\"\"\n</code></pre>"},{"location":"reference/resolver/#tidi.resolver.ResolverOptions","title":"<code>ResolverOptions</code>  <code>dataclass</code>","text":"<p>Options that control how resolving is done.</p> <p>Parameters:</p> Name Type Description Default <code>use_registry</code> <code>bool</code> <p>whether to try using the registry or not.</p> required <code>initialise_missing</code> <code>bool</code> <p>whether to try to initialise the dependency or not.</p> required Source code in <code>src/tidi/resolver.py</code> <pre><code>@dataclass(frozen=True)\nclass ResolverOptions:\n    \"\"\"Options that control how resolving is done.\n\n    Args:\n        use_registry (bool): whether to try using the registry or not.\n        initialise_missing (bool): whether to try to initialise the dependency or not.\n\n    \"\"\"\n\n    use_registry: bool\n    initialise_missing: bool\n</code></pre>"},{"location":"reference/resolver/#tidi.resolver.resolve_dependency","title":"<code>resolve_dependency(type_, resolver_options, registry=None, provider=None)</code>","text":"<p>Returns a dependency according to configured options.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>Type[T]</code> <p>the type of the dependency being looked for.</p> required <code>resolver_options</code> <code>ResolverOptions</code> <p>options dictating how to resolve the dependency.</p> required <code>registry</code> <code>Registry | None</code> <p>an optional registry containing the dependency. Defaults to None.</p> <code>None</code> <code>provider</code> <code>Callable[..., T] | None</code> <p>an optional function that will return the dependency. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>DependencyResolutionError</code> <p>if a registry is required but not provided</p> <code>DependencyResolutionError</code> <p>if the function doesn't know how to handle the situation</p> <p>Returns:</p> Type Description <code>type requested (T)</code> <p>an instance of the dependency requested.</p> Source code in <code>src/tidi/resolver.py</code> <pre><code>def resolve_dependency(\n    type_: t.Type[T],\n    resolver_options: ResolverOptions,\n    registry: Registry | None = None,\n    provider: t.Callable[..., T] | None = None,\n) -&gt; T:\n    \"\"\"Returns a dependency according to configured options.\n\n    Args:\n        type_ (typing.Type[T]): the type of the dependency being looked for.\n        resolver_options (ResolverOptions): options dictating how to resolve\n            the dependency.\n        registry (Registry | None, optional): an optional registry containing\n            the dependency. Defaults to None.\n        provider (typing.Callable[..., T] | None, optional): an optional\n            function that will return the dependency. Defaults to None.\n\n    Raises:\n        DependencyResolutionError: if a registry is required but not provided\n        DependencyResolutionError: if the function doesn't know how to handle the situation\n\n    Returns:\n        (type requested (T)): an instance of the dependency requested.\n    \"\"\"\n    match resolver_options:\n        case ResolverOptions(use_registry=True, initialise_missing=False) if registry is not None:\n            return registry.get(type_)\n        case ResolverOptions(use_registry=True, initialise_missing=False) if registry is None:\n            raise DependencyResolutionError(\"Registry required but not provided.\")\n        case ResolverOptions(use_registry=True, initialise_missing=True) if registry is not None:\n            obj = registry.get(type_, None)\n            return obj if obj is not None else _initialise_dependency(type_, provider)\n        case ResolverOptions(initialise_missing=True) if registry is None:\n            return _initialise_dependency(type_, provider)\n    raise DependencyResolutionError(\"Unable to resolve dependency.\")\n</code></pre>"}]}